MOST IMPORTANTE!:P(A/B) = P(A∩B) / P(B)

T+=(HIV∩T+)∪(HIVC∩T+)

P(A)=P(B∩A)+P(B'∩A)
P(Delay)=P(Boeing∩Delay)+P(Airbus∩Delay)+P(ERJ∩Delay)
A=(B1∩A)∪(B2∩A)∪(B3∩A)∪(B4∩A)

P(A)=P(B1∩A)+P(B2∩A)+P(B3∩A)+P(B4∩A)
= (P(A)=n∑i=1P(Bi)⋅P(A|Bi))


Multiple bayes:
P(Spam|w1,w2,w3,w4)∝P(Spam)⋅P(w1|Spam)⋅P(w2|Spam)⋅P(w3|Spam)⋅P(w4|Spam)


.get with "False" = defualt when not found!: sampling_distribution.get(df, False)

distribution = fit_distribution(data["flashpoint"])
pd.Series(distribution.pdf(data["flashpoint"]))
not_acid_prior = data["is_acid"].value_counts(normalize = True)[0]
is_acid_prior = data["is_acid"].value_counts(normalize = True)[1]
is_acid = data[data["is_acid"] == 1].copy()
not_acid = data[data["is_acid"] == 0].copy()
is_acid_dis = fit_distribution(is_acid["flashpoint"])
not_acid_dis = fit_distribution(not_acid["flashpoint"])
prob_is_acid = is_acid_prior * is_acid_dis.pdf(data["flashpoint"]) 
prob_not_acid = not_acid_prior * not_acid_dis.pdf(data["flashpoint"])
pd.Series(prob_is_acid > prob_not_acid).value_counts()

for i, obs in enumerate(observed):
    exp = expected[i]
    value = (obs - exp) ** 2 / exp
    values.append(value)

Cross tables:
table = pandas.crosstab(income["sex"], [income["high_income"]])

Cross tables p-value:
import numpy as np
from scipy.stats import chi2_contingency
observed = np.array([[5, 5], [10, 10]])
chisq_value, pvalue, df, expected = chi2_contingency(observed)


calculate pvalue! stats.chi2.pdf(3.84 , 1) .pdf(chisquare, degree of freedom/df)


Normalising text!:
(import re!!!! regional expressions aka regex)
def normalize_text(text):
    text = str(text).lower() # converting the string to lowercase
    normalized_text = re.sub("[^\w\s]", "", text) # removing all punctuation with a regex that excludes word and space characters 
    return normalized_text

# Applying the function to the Question and Answer columns (example!)
jeopardy['clean_question'] = jeopardy['Question'].apply(normalize_text)
jeopardy['clean_answer'] = jeopardy['Answer'].apply(normalize_text)

dict(data["is_ionic"].value_counts(normalize = True))
